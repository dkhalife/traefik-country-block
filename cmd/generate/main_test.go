package main

import (
	"bytes"
	"encoding/binary"
	"os"
	"strings"
	"testing"
)

// buildSyntheticBIN creates a minimal IP2Location-style BIN database in memory.
// It contains the 64-byte header, one IPv4 record, one IPv6 record, and two
// length-prefixed country code strings.
func buildSyntheticBIN(dbColumns uint8, ipv4Count, ipv6Count uint32) []byte {
	// Layout:
	//  [0..63]   header
	//  [64..]    country strings (padded to 256 bytes so readStr can read 256 from ptr)
	//  then      IPv4 rows
	//  then      IPv6 rows

	ipv4ColSize := uint32(dbColumns) * 4
	ipv6ColSize := 16 + (uint32(dbColumns)-1)*4

	// Country strings (length-prefixed): "-" at offset 64, "US" at offset 66
	// Pad to at least 256 bytes from offset 64 so readStr can read a full 256 buffer
	strBase := uint32(64)
	strAreaSize := uint32(512) // enough padding for 256-byte reads from any ptr
	strArea := make([]byte, strAreaSize)
	strArea[0] = 1   // length
	strArea[1] = '-' // "-" at offset 64
	strArea[2] = 2   // length
	strArea[3] = 'U' // "US" at offset 66
	strArea[4] = 'S'

	// IPv4 rows start right after string area
	ipv4Start := strBase + strAreaSize
	// The offset stored in header is 1-indexed
	ipv4Addr := ipv4Start + 1

	// IPv6 rows start after IPv4 rows
	ipv6Start := ipv4Start + ipv4Count*ipv4ColSize
	ipv6Addr := ipv6Start + 1

	totalSize := ipv6Start + ipv6Count*ipv6ColSize
	data := make([]byte, totalSize)

	// --- Header ---
	data[0] = 1         // dbType
	data[1] = dbColumns // dbColumn
	data[2] = 26        // year
	data[3] = 1         // month
	data[4] = 15        // day
	binary.LittleEndian.PutUint32(data[5:9], ipv4Count)
	binary.LittleEndian.PutUint32(data[9:13], ipv4Addr)
	binary.LittleEndian.PutUint32(data[13:17], ipv6Count)
	binary.LittleEndian.PutUint32(data[17:21], ipv6Addr)

	// --- Country strings ---
	copy(data[strBase:], strArea)

	// --- IPv4 rows: each row is ipv4ColSize bytes ---
	// Row format: [4B LE ip_from][4B LE country_string_ptr][... extra cols]
	for i := uint32(0); i < ipv4Count; i++ {
		off := ipv4Start + i*ipv4ColSize
		ipFrom := uint32(16777216) + i*256 // 1.0.x.0
		binary.LittleEndian.PutUint32(data[off:off+4], ipFrom)
		// Point to "US" string at offset 66
		binary.LittleEndian.PutUint32(data[off+4:off+8], 66)
	}

	// --- IPv6 rows: each row is ipv6ColSize bytes ---
	// Row format: [16B BE ip_from (hi+lo)][4B LE country_string_ptr][... extra cols]
	for i := uint32(0); i < ipv6Count; i++ {
		off := ipv6Start + i*ipv6ColSize
		// Some IPv6 from value
		binary.BigEndian.PutUint64(data[off:off+8], uint64(i+1)*1000)
		binary.BigEndian.PutUint64(data[off+8:off+16], 0)
		// Point to "US" string at offset 66
		binary.LittleEndian.PutUint32(data[off+16:off+20], 66)
	}

	return data
}

type bytesReaderAt struct {
	data []byte
}

func (b *bytesReaderAt) ReadAt(p []byte, off int64) (int, error) {
	if off >= int64(len(b.data)) {
		return 0, &readAtError{"offset beyond data"}
	}
	n := copy(p, b.data[off:])
	if n < len(p) {
		return n, &readAtError{"short read"}
	}
	return n, nil
}

type readAtError struct{ msg string }

func (e *readAtError) Error() string { return e.msg }

func TestGenerate_Basic(t *testing.T) {
	binData := buildSyntheticBIN(2, 3, 2) // 2 columns, 3 IPv4 rows, 2 IPv6 rows
	reader := &bytesReaderAt{data: binData}

	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err != nil {
		t.Fatalf("generate failed: %v", err)
	}

	output := buf.String()

	// Verify output structure
	if !strings.Contains(output, "// Code generated by go generate; DO NOT EDIT.") {
		t.Error("missing generated header")
	}
	if !strings.Contains(output, "package traefik_country_block") {
		t.Error("missing package declaration")
	}
	if !strings.Contains(output, "var geoCountryCodes = []string{") {
		t.Error("missing country codes")
	}
	if !strings.Contains(output, `"-"`) {
		t.Error("missing dash country code")
	}
	if !strings.Contains(output, `"US"`) {
		t.Error("missing US country code")
	}
	if !strings.Contains(output, "geoIPv4Data") {
		t.Error("missing IPv4 data const")
	}
	if !strings.Contains(output, "geoIPv6Data") {
		t.Error("missing IPv6 data const")
	}
	if !strings.Contains(output, "20260115") && !strings.Contains(output, "2026-01-15") {
		// Just verify the date appears somewhere in the output
		if !strings.Contains(output, "26-01-15") {
			t.Error("missing date in output")
		}
	}
}

func TestGenerate_ZeroRecords(t *testing.T) {
	binData := buildSyntheticBIN(2, 0, 0)
	reader := &bytesReaderAt{data: binData}

	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err != nil {
		t.Fatalf("generate failed: %v", err)
	}

	output := buf.String()
	if !strings.Contains(output, "geoIPv4Data") {
		t.Error("missing IPv4 data const")
	}
}

func TestGenerate_MergesConsecutiveSameCountry(t *testing.T) {
	// All 3 rows point to same country "US" → should merge to 1
	binData := buildSyntheticBIN(2, 3, 2)
	reader := &bytesReaderAt{data: binData}

	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err != nil {
		t.Fatalf("generate failed: %v", err)
	}

	// The output should have both consts
	output := buf.String()
	if !strings.Contains(output, "geoIPv4Data") {
		t.Error("missing IPv4 data")
	}
	if !strings.Contains(output, "geoIPv6Data") {
		t.Error("missing IPv6 data")
	}
}

func TestGenerate_HeaderReadError(t *testing.T) {
	// Empty data → can't read header
	reader := &bytesReaderAt{data: []byte{}}
	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err == nil {
		t.Fatal("expected error for empty input")
	}
	if !strings.Contains(err.Error(), "header") {
		t.Fatalf("expected header error, got: %v", err)
	}
}

func TestGenerate_IPv4ReadError(t *testing.T) {
	// Header says there are IPv4 records, but data is too short
	binData := make([]byte, 64)                      // only header, no rows
	binData[1] = 2                                   // 2 columns
	binary.LittleEndian.PutUint32(binData[5:9], 1)   // 1 IPv4 record
	binary.LittleEndian.PutUint32(binData[9:13], 65) // points beyond data
	binary.LittleEndian.PutUint32(binData[13:17], 0) // no IPv6

	reader := &bytesReaderAt{data: binData}
	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err == nil {
		t.Fatal("expected error for IPv4 read failure")
	}
	if !strings.Contains(err.Error(), "IPv4") {
		t.Fatalf("expected IPv4 error, got: %v", err)
	}
}

func TestGenerate_IPv6ReadError(t *testing.T) {
	// Create valid data for 0 IPv4 records but 1 IPv6 record pointing beyond data
	binData := make([]byte, 64)
	binData[1] = 2                                     // 2 columns
	binary.LittleEndian.PutUint32(binData[5:9], 0)     // 0 IPv4 records
	binary.LittleEndian.PutUint32(binData[9:13], 65)   // doesn't matter
	binary.LittleEndian.PutUint32(binData[13:17], 1)   // 1 IPv6 record
	binary.LittleEndian.PutUint32(binData[17:21], 128) // points beyond data

	reader := &bytesReaderAt{data: binData}
	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err == nil {
		t.Fatal("expected error for IPv6 read failure")
	}
	if !strings.Contains(err.Error(), "IPv6") {
		t.Fatalf("expected IPv6 error, got: %v", err)
	}
}

func TestGenerate_MixedCountries(t *testing.T) {
	// Build a BIN with 2 IPv4 rows pointing to different countries
	dbColumns := uint8(2)
	ipv4ColSize := uint32(dbColumns) * 4

	// Strings: "-" at 64, "US" at 66, "CN" at 69
	// Need 512 bytes padding for readStr's 256-byte read
	strBase := uint32(64)
	strAreaSize := uint32(512)
	strArea := make([]byte, strAreaSize)
	strArea[0] = 1 // "-" at 64
	strArea[1] = '-'
	strArea[2] = 2 // "US" at 66
	strArea[3] = 'U'
	strArea[4] = 'S'
	strArea[5] = 2 // "CN" at 69
	strArea[6] = 'C'
	strArea[7] = 'N'

	ipv4Count := uint32(2)
	ipv6Count := uint32(0)

	ipv4Start := strBase + strAreaSize
	ipv4Addr := ipv4Start + 1
	ipv6Start := ipv4Start + ipv4Count*ipv4ColSize
	ipv6Addr := ipv6Start + 1

	totalSize := ipv6Start + ipv6Count*0
	data := make([]byte, totalSize)

	data[0] = 1
	data[1] = dbColumns
	data[2] = 26
	data[3] = 2
	data[4] = 1
	binary.LittleEndian.PutUint32(data[5:9], ipv4Count)
	binary.LittleEndian.PutUint32(data[9:13], ipv4Addr)
	binary.LittleEndian.PutUint32(data[13:17], ipv6Count)
	binary.LittleEndian.PutUint32(data[17:21], ipv6Addr)

	copy(data[strBase:], strArea)

	// Row 0: ip=1.0.0.0, country="US" (ptr=66)
	off0 := ipv4Start
	binary.LittleEndian.PutUint32(data[off0:off0+4], 16777216)
	binary.LittleEndian.PutUint32(data[off0+4:off0+8], 66)

	// Row 1: ip=2.0.0.0, country="CN" (ptr=69)
	off1 := ipv4Start + ipv4ColSize
	binary.LittleEndian.PutUint32(data[off1:off1+4], 33554432)
	binary.LittleEndian.PutUint32(data[off1+4:off1+8], 69)

	reader := &bytesReaderAt{data: data}
	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err != nil {
		t.Fatalf("generate failed: %v", err)
	}

	output := buf.String()
	if !strings.Contains(output, `"US"`) || !strings.Contains(output, `"CN"`) {
		t.Errorf("expected both US and CN in output, got:\n%s", output)
	}
}

func TestGenerate_EmptyCountryString(t *testing.T) {
	// Build BIN where country string has length 0 → should map to "-"
	dbColumns := uint8(2)
	ipv4ColSize := uint32(dbColumns) * 4

	// String at offset 64: length=0 (empty → should be "-")
	strArea := []byte{0}
	strBase := uint32(64)

	ipv4Count := uint32(1)
	ipv4Start := strBase + uint32(len(strArea))
	ipv4Addr := ipv4Start + 1

	totalSize := ipv4Start + ipv4Count*ipv4ColSize
	data := make([]byte, totalSize)

	data[0] = 1
	data[1] = dbColumns
	binary.LittleEndian.PutUint32(data[5:9], ipv4Count)
	binary.LittleEndian.PutUint32(data[9:13], ipv4Addr)
	binary.LittleEndian.PutUint32(data[13:17], 0) // no IPv6
	binary.LittleEndian.PutUint32(data[17:21], uint32(totalSize)+1)

	copy(data[strBase:], strArea)

	off := ipv4Start
	binary.LittleEndian.PutUint32(data[off:off+4], 16777216)
	binary.LittleEndian.PutUint32(data[off+4:off+8], 64) // points to empty string

	reader := &bytesReaderAt{data: data}
	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err != nil {
		t.Fatalf("generate failed: %v", err)
	}

	output := buf.String()
	if !strings.Contains(output, `"-"`) {
		t.Error("expected dash for empty country string")
	}
}

func TestGenerate_StringReadError(t *testing.T) {
	// Build BIN where country ptr points beyond file → readStr returns "-"
	dbColumns := uint8(2)
	ipv4ColSize := uint32(dbColumns) * 4

	ipv4Count := uint32(1)
	strBase := uint32(64)
	ipv4Start := strBase
	ipv4Addr := ipv4Start + 1

	totalSize := ipv4Start + ipv4Count*ipv4ColSize
	data := make([]byte, totalSize)

	data[0] = 1
	data[1] = dbColumns
	binary.LittleEndian.PutUint32(data[5:9], ipv4Count)
	binary.LittleEndian.PutUint32(data[9:13], ipv4Addr)
	binary.LittleEndian.PutUint32(data[13:17], 0)
	binary.LittleEndian.PutUint32(data[17:21], uint32(totalSize)+1)

	off := ipv4Start
	binary.LittleEndian.PutUint32(data[off:off+4], 16777216)
	binary.LittleEndian.PutUint32(data[off+4:off+8], 99999) // points way beyond data

	reader := &bytesReaderAt{data: data}
	var buf bytes.Buffer
	err := generate(reader, &buf)
	if err != nil {
		t.Fatalf("generate failed: %v", err)
	}

	// readStr should have returned "-" for the bad pointer
	output := buf.String()
	if !strings.Contains(output, `"-"`) {
		t.Error("expected dash for read error fallback")
	}
}

func TestWriteBase64Const(t *testing.T) {
	var buf bytes.Buffer
	writeBase64Const(&buf, "testConst", "SGVsbG8=")
	output := buf.String()
	if !strings.Contains(output, "const testConst") {
		t.Error("missing const declaration")
	}
	if !strings.Contains(output, "SGVsbG8=") {
		t.Error("missing base64 value")
	}
}

func TestRun_BadBinPath(t *testing.T) {
	err := run("/nonexistent/path/to/db.bin", "/tmp/out.go")
	if err == nil {
		t.Fatal("expected error for non-existent bin path")
	}
}

func TestRun_BadOutputPath(t *testing.T) {
	// Create a temp bin file with valid header
	binData := buildSyntheticBIN(2, 0, 0)
	tmpBin := t.TempDir() + "/test.bin"
	if err := os.WriteFile(tmpBin, binData, 0644); err != nil {
		t.Fatalf("failed to write temp bin: %v", err)
	}

	err := run(tmpBin, "/nonexistent/dir/sub/out.go")
	if err == nil {
		t.Fatal("expected error for bad output path")
	}
}

func TestRun_Success(t *testing.T) {
	binData := buildSyntheticBIN(2, 2, 1)
	tmpDir := t.TempDir()
	tmpBin := tmpDir + "/test.bin"
	tmpOut := tmpDir + "/geodata.go"

	if err := os.WriteFile(tmpBin, binData, 0644); err != nil {
		t.Fatalf("failed to write temp bin: %v", err)
	}

	err := run(tmpBin, tmpOut)
	if err != nil {
		t.Fatalf("run failed: %v", err)
	}
}
